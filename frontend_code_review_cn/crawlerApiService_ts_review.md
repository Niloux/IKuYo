# `frontend/src/services/crawlerApiService.ts` 代码审查\n\n## 分析\n\n`crawlerApiService.ts` 文件负责处理与后端爬虫任务和计划任务相关的 API 通信。它依赖于 `api.ts` 中定义的 `apiClient`。\n\n1.  **类型定义**: 定义了与爬虫任务和计划任务相关的 TypeScript 接口，如 `CrawlerTaskCreate`、`TaskResponse`、`ScheduledJobCreate`、`ScheduledJobResponse` 等，这些类型与后端 `ikuyo/api/models/schemas.py` 中的定义相对应。\n2.  **CrawlerApiService**: 封装了多个与爬虫任务和计划任务交互的方法，包括创建、列出、获取、取消任务，以及获取任务进度。还包含了计划任务的列表、创建、更新、删除和切换状态的方法。\n3.  **WebSocket 连接**: 提供了 `connectTaskProgressWs` 方法用于建立 WebSocket 连接以获取实时任务进度更新。\n4.  **类型断言**: 在多个 API 调用后使用了 `as unknown as SomeType` 进行类型断言。\n\n## 建议和理由\n\n### 1. 类型断言 `as unknown as SomeType` 的使用\n\n*   **建议**: 在多个方法中（如 `createTask`, `listTasks`, `getTask` 等）使用了 `response as unknown as TaskResponse` 这样的类型断言。虽然这可以强制 TypeScript 接受类型，但它绕过了类型检查，如果后端返回的数据结构与 `TaskResponse` 不符，可能会导致运行时错误。\n*   **理由**: 理想情况下，`apiClient` 的响应拦截器应该已经处理了 `ApiResponse` 的解构，使得 `apiClient.post` 或 `apiClient.get` 直接返回 `ApiResponse<T>` 中的 `data` 部分。如果 `apiClient` 已经返回了 `T` 类型的数据，那么这里就不需要 `as unknown as SomeType`。如果 `apiClient` 返回的是完整的 `ApiResponse<T>`，那么应该访问 `response.data`。请检查 `api.ts` 中的 `apiClient` 响应拦截器，确保其返回类型与期望一致，从而消除不必要的类型断言。\n\n### 2. `getTaskProgress` 方法\n\n*   **建议**: `getTaskProgress` 方法的注释中提到“HTTP轮询方式，不推荐用于实时更新”，并且其返回类型是 `Promise<any>`。这表明它可能是一个遗留或备用方法。\n*   **理由**: 如果主要使用 WebSocket 进行实时更新，可以考虑：\n    *   如果 `getTaskProgress` 确实不再使用，可以将其移除以减少代码量。\n    *   如果它作为备用方案存在，应明确其用途，并考虑为其定义更具体的返回类型，而不是 `any`。\n\n### 3. WebSocket 连接的 `wsHost` 构建\n\n*   **建议**: 在 `connectTaskProgressWs` 方法中，`wsHost` 的构建方式是 `apiClient.defaults.baseURL?.replace(/https?:\/\//, '')`。这假设 WebSocket 服务与 HTTP API 在同一主机和端口，并且 `baseURL` 总是包含协议。\n*   **理由**: 这种构建方式可能不够健壮。更推荐的做法是：\n    *   为 WebSocket 服务定义一个单独的环境变量（例如 `VITE_WS_BASE_URL`），以明确指定 WebSocket 服务器的地址，避免依赖 HTTP API 的 `baseURL`。\n    *   如果 WebSocket 服务确实与 HTTP API 在同一主机，但端口或路径不同，确保 `replace` 逻辑能够正确处理所有情况，或者直接从 `window.location.host` 获取主机名。\n\n### 4. 计划任务 API 路径的一致性\n\n*   **建议**: 在 `listScheduledJobs` 方法中，API 路径是 `/api/v1/scheduler/jobs`，而在 `createScheduledJob`、`updateScheduledJob` 等方法中，路径是 `/scheduler/jobs`（因为 `apiClient` 的 `baseURL` 已经包含了 `/api/v1`）。\n*   **理由**: 保持 API 路径的一致性可以避免混淆。建议所有计划任务相关的 API 调用都使用相对路径，即 `apiClient.get('/scheduler/jobs')`，这样它们都会自动加上 `baseURL`。\n\n### 5. `parameters: any` 的类型细化\n\n*   **建议**: `ScheduledJobCreate` 和 `ScheduledJobResponse` 中的 `parameters: any` 类型过于宽泛。虽然注释说明它将是一个 JSON 对象，但 `any` 失去了类型检查的优势。\n*   **理由**: 建议为 `parameters` 定义更具体的类型，例如 `Record<string, any>`，或者如果 `parameters` 的结构是固定的，可以定义一个专门的接口。这有助于在开发时捕获潜在的类型错误，并提供更好的代码提示。\n\n### 6. 日期时间字符串的类型\n\n*   **建议**: `TaskResponse` 和 `ScheduledJobResponse` 中的 `created_at`、`started_at`、`completed_at`、`updated_at` 字段被定义为 `string`，并注释说明是“datetime objects are usually stringified in JSON”。\n*   **理由**: 如果这些日期时间字符串在前端需要进行日期操作或格式化，可以考虑使用 `Date` 类型，并在接收到数据后进行转换。或者，如果始终作为字符串处理，则保持 `string` 类型是合理的，但要确保在显示时进行适当的格式化。\n\n### 总结\n\n`crawlerApiService.ts` 提供了对爬虫和计划任务的良好 API 封装。主要的改进点在于消除不必要的类型断言，优化 WebSocket 连接的构建方式，统一 API 路径，以及细化 `parameters` 等 `any` 类型的定义，以提高代码的健壮性和可维护性。
